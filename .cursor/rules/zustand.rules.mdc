---
description: Use when creating or updating global state logic.
globs: 
alwaysApply: false
---
/**
 * Rule: Zustand usage in real-time apps (e.g., games, audio, MIDI, UI sync)
 *
 * Applies To: React apps requiring low-latency global state, especially
 * when integrated with @react-three/fiber or MIDI/Web Audio systems.
 *
 * Primary use: Time-driven systems (e.g. scroll offset, audio sync),
 * MIDI input (drum triggers), and reactive UI/visual logic.
 */

export const zustandRule = {
  //
  // ðŸ§± FILE & ORGANIZATION PATTERNS
  //
  folders: [
    "ðŸ“ state/                     â†’ colocate all zustand stores here",
    " â”œâ”€ useGameStore.ts          â†’ bpm, time, score, play state",
    " â”œâ”€ useMidiStore.ts          â†’ raw hits, current hit, velocity buffer",
    " â””â”€ useUIStore.ts            â†’ dev mode, overlays, latency offset, toggles",
  ],

  //
  // âœ… STORE STRUCTURE PATTERN
  //
  storeTemplate: `
  const useStore = create(() => ({
    time: 0,
    bpm: 120,
    isPlaying: false,
    score: 0,
    setTime: (time: number) => set({ time }),
    togglePlay: () => set((s) => ({ isPlaying: !s.isPlaying })),
  }))
  `,

  //
  // ðŸŽ¯ BEST PRACTICES
  //
  practices: [
    "Use Zustand for cross-component state with shared lifecycles (time, hits, playback).",
    "Use `.getState()` or `.subscribe()` outside React (e.g. useFrame, MIDI listeners).",
    "Use selector functions to avoid full-store subscriptions in components.",
    "Group actions with data in a flat structure per store.",
    "Use devtools middleware for debugging (only in dev).",
    "Store only serializable primitives or arrays â€” avoid non-serializable refs or DOM elements.",
  ],

  //
  // âš ï¸ WARNING SIGNS
  //
  antiPatterns: [
    "âŒ useState for time or hit state in R3F or MIDI-heavy contexts.",
    "âŒ useContext to pass mutable data â€” Zustand should be the shared system.",
    "âŒ One giant store with all game/audio/UI logic in one blob.",
    "âŒ Setting state too frequently inside `useFrame` without batching.",
    "âŒ Updating entire objects instead of partial patches (e.g. overwriting deep arrays).",
    "âŒ Storing DOM refs or Three.js objects inside Zustand.",
  ],

  //
  // ðŸ§  ADVANCED PATTERNS
  //
  advanced: [
    {
      label: "ðŸ§µ use `subscribe()` to bind store state to outside systems",
      example: `
const unsub = useGameStore.subscribe((s) => s.isPlaying, (val) => {
  val ? startAudioEngine() : stopAudioEngine()
})
      `,
    },
    {
      label: "ðŸ•¹ï¸ External triggers (MIDI, audio) â†’ call .getState() directly",
      example: `
const { addHit } = useMidiStore.getState()
addHit({ type: "kick", time: performance.now() / 1000 })
      `,
    },
    {
      label: "ðŸªž use shallow equality for selector usage",
      example: `
const { time, bpm } = useGameStore((s) => ({ time: s.time, bpm: s.bpm }), shallow)
      `,
    },
    {
      label: "ðŸŽ›ï¸ Use Leva to bind directly to Zustand",
      example: `
const { offset } = useControls(() => ({
  offset: {
    value: useUIStore.getState().latencyOffset,
    onChange: (v) => useUIStore.setState({ latencyOffset: v })
  }
}))
      `,
    },
    {
      label: "ðŸ“¡ Use `subscribeWithSelector` for scoped reactivity",
      note: "This avoids stale subscriptions and is better for performance.",
    },
  ],

  //
  // ðŸ§© STORE COMPOSITION STRATEGY
  //
  composition: [
    "1 store per concern: time/audio/game, midi/hits, UI/debug",
    "If a concern is shareable across apps (e.g. audio transport), create a base store in `packages/shared/state`",
    "Use `.getState()` for immediate access, `.subscribe()` for external reactivity, and selector hooks for UI reactivity",
  ],

  //
  // ðŸ“ˆ RECOMMENDED DEPENDENCIES
  //
  deps: [
    "zustand",
    "zustand/middleware (for devtools)",
    "zustand/shallow (for selector comparison)",
  ],
}
